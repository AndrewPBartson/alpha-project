<?xml version="1.0" encoding="UTF-8"?>
<opml version="1.0" xmlns:sx="http://www.microsoft.com/schemas/rss/sse">
<head>
  <title>JS Array Methods</title> 
  <dateCreated>2008-08-26T08:00:07</dateCreated>
  <dateModified>2022-11-16T00:47:36</dateModified>
</head>
<body>
<outline text="Syntax note -">
  <outline text="[, itemN]">
    <sx:sync version="1" id="QzCzFXyTSEGYMPacc6zHNg==" />
  </outline>
  <outline text="Means - method takes any number of elements">
    <sx:sync version="1" id="2DqrhDjQ4UWoM1FUDDieIQ==" />
  </outline>
  <outline text="Example - ">
    <outline text="a.concat(item[, itemN])">
      <sx:sync version="1" id="/Vz+K55iEUO6ox3l5ahz+w==" />
    </outline>
    <sx:sync version="1" id="Ou4Oq9vmSEGtqbwJwFLCSw==" />
  </outline>
  <sx:sync version="1" id="XYInLwzaLEik/KVqjRzE7A==" />
</outline>
<outline text="Array.from()">
  <outline text="- convert Nodelist and HTMLCollection to real array">
    <sx:sync version="1" id="g6WGUgNsMkKjddyh4bM8Aw==" />
  </outline>
  <outline text="const nodelist = &#xA;   document.querySelectorAll(‘.product’)">
    <sx:sync version="1" id="4Y0N9h0LbkixFATZwJaKOA==" />
  </outline>
  <outline text="const productArray = Array.from(nodelist)">
    <sx:sync version="1" id="eEf4fPmNJUyWfCv+GJDAUw==" />
  </outline>
  <outline text="let revProducts = productArray.reverse();">
    <sx:sync version="1" id="Kp9NdITwK0OGX+rJsgOh0Q==" />
  </outline>
  <sx:sync version="1" id="9gV4G35Bm0q1UI/GG7g8xw==" />
</outline>
<outline text="Destructive / Non-destructive"><sx:sync version="1" id="iZrGaHBchk+kJKpRW8XPsg==" /></outline><outline text="indexOf(searchElement[, from])"><outline text="Find all occurrences of element"><outline text="var indices = [];&#xA;var array = ['a', 'b', 'a', 'c', 'a', 'd'];&#xA;var element = 'a';&#xA;var idx = array.indexOf(element);&#xA;while (idx != -1) {&#xA;  indices.push(idx);&#xA;  idx = array.indexOf(element, idx + 1);&#xA;}&#xA;console.log(indices);&#xA;// [0, 2, 4]"><sx:sync version="1" id="vr4UA481jkaJg9IusSaEBQ==" /></outline><outline text="var indices = [];&#xA;var chars = ['a', 'b', 'a', 'c', 'a', 'd'];&#xA;var element = 'a';&#xA;var idx = chars.indexOf(element);&#xA;while (idx != -1) {&#xA;  indices.push(idx);&#xA;  idx = chars.indexOf(element, idx + 1);&#xA;}&#xA;console.log(indices);&#xA;// [0, 2, 4]"><sx:sync version="1" id="wQiDY0l0n0q/CrGgbfgS7Q==" /></outline><sx:sync version="1" id="XYLoq5bBDEeBZ7Uki/+jxQ==" /></outline><outline text="var a = [2, 9, 9]; &#xA;a.indexOf(2); // 0 &#xA;a.indexOf(7); // -1 // element not in array"><sx:sync version="1" id="Yce6fwoMn0W76pKkt2hsxw==" /></outline><outline text="Parameters"><sx:sync version="1" id="OcBgX3UA0kSiwQcCIIMnKw==" /></outline><outline text="searchElement"><outline text="Element to locate in the array."><sx:sync version="1" id="Y2sC7sNJsEuqKCGTWuLt6g==" /></outline><sx:sync version="1" id="KqfT05LOKEq7sQjz1FbtnQ==" /></outline><outline text="fromIndex"><outline text="Optional"><sx:sync version="1" id="H2G5u9LmSUSte3XQydUxgA==" /></outline><outline text="Index to start searching"><sx:sync version="1" id="Nrm66hQT6061rpq2nGkxRQ==" /></outline><outline text="If the index is greater than or equal to array's length, -1 is returned, which means array is not searched."><sx:sync version="1" id="Iq5EimnFXESNS5vAzmleIg==" /></outline><outline text="If the provided index value is a negative number, it is taken as the offset from the end of the array. Note: if provided index is negative, the array is still searched from front to back. If the calculated index is less than 0, then the whole array will be searched. Default: 0 (entire array is searched)."><sx:sync version="1" id="uI08WlHkfke0/uEYidT7yQ==" /></outline><sx:sync version="1" id="zGcWNC+zh0mQyght2eccvQ==" /></outline><outline text="Returns first index of searchElement in array; -1 if not found."><sx:sync version="1" id="pxbLMDuRKECbmOlpiu/dmg==" /></outline><sx:sync version="1" id="HdSq0EYR60i5vLK4Gdcsaw==" /></outline><outline text="isArray(val)"><outline text="Tells if the passed value is an Array"><sx:sync version="1" id="OEqgiOlDeEW8FWLVV/k5Kw==" /></outline><outline text="if (Array.isArray(input) {&#xA;    // do something&#xA;}"><sx:sync version="1" id="NXTyban6Y0GuM4sl5SRdTA==" /></outline><outline text="Returns a boolean"><sx:sync version="1" id="PiyPzCyxa0yzude+RkzztQ==" /></outline><sx:sync version="1" id="58axMzJYzkGWooQTddTjIg==" /></outline><outline text="join(sep)"><outline text="Joins array items to a string - w/ items delimited by &quot;sep&quot; parameter"><sx:sync version="1" id="9BKFdbLOM0Oitp6R0tDAlQ==" /></outline><outline text="var animals = [&quot;monkey&quot;, &quot;cat&quot;, &quot;fish&quot;, &quot;lizard&quot;];&#xA;var animal_str = animals.join();  // inserts commas&#xA;var animal_str_2 = animals.join(&quot;&quot;); // monkeycatfishlizard"><sx:sync version="1" id="aAlGmwBnx0iOrUK/I1vJhA==" /></outline><sx:sync version="1" id="9gUkyedxPUygEaAN83pzDg==" /></outline><outline text="pop()"><outline text="Removes element from the end"><sx:sync version="1" id="2msL/BUTLkex8/QPQyYVcQ==" /></outline><outline text="Returns last element"><sx:sync version="1" id="WFp6/A62qkWmqW+DXnyTPA==" /></outline><sx:sync version="1" id="rXYvSLa9cUKXLHfSyScS7A==" /></outline><outline text="push(item[, itemN])"><outline text="Adds element(s) to the end"><sx:sync version="1" id="cBBBb9T/M0yHga4GQKa4UQ==" /></outline><outline text="arr.push(1);"><sx:sync version="1" id="OEX/9er+6UOMftWtcezItw==" /></outline><outline text="Weird ability of push -"><outline text="let journal = [];&#xA;&#xA;function addEntry(events, squirrel) {&#xA;  journal.push({events, squirrel});&#xA;}&#xA;console.log(journal);&#xA;// []&#xA;addEntry(&quot;test&quot;, &quot;happy&quot;);&#xA;console.log(journal);&#xA;// [{events: &quot;test&quot;, squirrel: &quot;happy&quot;}]"><sx:sync version="1" id="/5edQw6N/0WcMPzq307Q5A==" /></outline><outline text="&quot;If a property name in brace notation isn’t followed by a value, its value is taken from the binding with the same name.&quot;"><sx:sync version="1" id="toGuILOqtEOtDOhM/PAEfw==" /></outline><sx:sync version="1" id="NhW850Too0Kl58+tubCt5Q==" /></outline><outline text="Returns new length of array"><sx:sync version="1" id="zd6bFSkOc0mHrAAycSGcKw==" /></outline><sx:sync version="1" id="8XlDFgRviECsDl1L5Su+AA==" /></outline><outline text="shift()"><outline text="Removes element from the start"><sx:sync version="1" id="Yi7P2cLbv0mdUSltjBdVlg==" /></outline><outline text="Returns first element"><sx:sync version="1" id="2slXp6oNF0GO5++IZe777A==" /></outline><sx:sync version="1" id="cMeAxgiOfUuZJ/x8rz/FWQ==" /></outline><outline text="unshift(item1, item2)"><outline text="Adds element(s) to the start"><sx:sync version="1" id="VlSH5UYbjEG67QIY8VMoTg==" /></outline><outline text="arr.unshift(1);"><sx:sync version="1" id="h4USOqHJPEq1MePX7d2hcA==" /></outline><outline text="Returns new length of array"><sx:sync version="1" id="XyOia/Zv7kSjxJQA48HKbg==" /></outline><sx:sync version="1" id="xgcDKYEbRkSLr/6rSeOvbg==" /></outline><outline text="splice(start, delcount[, itemN])"><outline text="Destructive"><sx:sync version="1" id="8frk3W2VAEaUigKa11fXng==" /></outline><outline text="- delete zero or more elements and replace with zero or more elements."><sx:sync version="1" id="m5INPMpuZUaRgo2JEyOovg==" /></outline><outline text="Params"><outline text="1) Start index in array"><outline text="Remove everything after start index, inclusive)"><sx:sync version="1" id="6AqJpFDG6kK1JrGccs/xQw==" /></outline><sx:sync version="1" id="HkDZOyQY9kW4BBQ/+SK8Hw==" /></outline><outline text="2) Number of elements to remove"><outline text="Default - Remove to the end"><sx:sync version="1" id="DNOKgqUinkWAbTIlqQcYjA==" /></outline><sx:sync version="1" id="APdJIPOSEk+h9nKo1HH0ug==" /></outline><outline text="3) Zero or more elements to add"><sx:sync version="1" id="ST4cpeuR5Eqy1esaI05TTA==" /></outline><sx:sync version="1" id="oFpzUNtgxkC5S+XZ1M+pwA==" /></outline><outline text="Params - more"><outline text="array.splice(start)&#xA;array.splice(start, deleteCount)&#xA;array.splice(start, deleteCount, item1, item2, ...)"><sx:sync version="1" id="p29wrSz7yEm/HZRJzRBVDw==" /></outline><outline text="start"><outline text="Index at which to start changing the array"><sx:sync version="1" id="1rep5mOEz0OegSIQYx6Nag==" /></outline><outline text="If greater than length of array, actual starting index will be set to length of array."><sx:sync version="1" id="tzlWFE2F1UeHbZTLOsvmPg==" /></outline><outline text="If negative, will begin that many elements from end of array (with origin -1) and will be set to 0 if absolute value is greater than length of array."><sx:sync version="1" id="70ZKVNoRXEehVR6LNEh00w==" /></outline><sx:sync version="1" id="D2nC59nzlk2AItPpeZ429Q==" /></outline><outline text="deleteCount"><outline text="Optional"><sx:sync version="1" id="n6Kh5NLtxkaEg5ke9zbFVg==" /></outline><outline text="An integer indicating the number of old array elements to remove. If deleteCount is 0, no elements are removed. In this case, you should specify at least one new element. If deleteCount is greater than the number of elements left in the array starting at start, then all of the elements through the end of the array will be deleted."><sx:sync version="1" id="fCknzH0oHkirq9MrXGjf7A==" /></outline><outline text="If deleteCount is omitted, or if its value is larger than array.length - start, then all of the elements beginning with start index on through the end of the array will be deleted."><sx:sync version="1" id="Qzgc+vzM9EujJWdXNw13Zw==" /></outline><sx:sync version="1" id="Wt/A3UHqt06T64j0mMw1Og==" /></outline><outline text="item1, item2, ..."><outline text="Optional"><sx:sync version="1" id="rnD6QP5hZ0ulpuu9Z/CLxg==" /></outline><outline text="The elements to add to the array, beginning at the start index. If you don't specify any elements, splice() will only remove elements from the array."><sx:sync version="1" id="jUg6oYtufEapeIk8heilyA==" /></outline><sx:sync version="1" id="nM8pOcDY5026LeqTBi8gfA==" /></outline><sx:sync version="1" id="JoGtuOUNvUS6BCF4aPW7sw==" /></outline><outline text="- Delete first element"><outline text="var fruits = ['Strawberry', 'Apple', 'Banana'];&#xA;var removedItem = fruits.splice(0, 1);&#xA;&#xA;console.log(fruits); &#xA;// ['Apple', 'Banana']"><sx:sync version="1" id="vzMaCE/zMUKVdncKfvp37A==" /></outline><sx:sync version="1" id="Ll5HnKJ8tUi79I8S/jo4jA==" /></outline><outline text="- Delete element from middle of array"><outline text="var letters = ['a', 'b', 'c', 'd']"><sx:sync version="1" id="4tcEh6m28E6DLzCNotCM8A==" /></outline><outline text="letters.splice(2, 1)"><sx:sync version="1" id="mLU7fwPPYUW0/K1Iir8m5Q==" /></outline><outline text="Remove the element at index 2"><sx:sync version="1" id="+ZhrLgmzqk6ARz6ozFguFg==" /></outline><outline text="// ['a', 'b', 'd']"><sx:sync version="1" id="i+8pExn8mkiBK2gtH1rU/w==" /></outline><outline text="Also possible with slice();"><sx:sync version="1" id="Kn+ixyStGk28lzuNgYQiYg==" /></outline><sx:sync version="1" id="qbHpxagIe0i3DB6SAXk3BQ==" /></outline><outline text="Delete element and replace with 2 elements"><outline text="var items = [1, 2, 3, 4]"><sx:sync version="1" id="0qSc3tfDlE2C0413Ujt97A==" /></outline><outline text="items.splice(1, 1, 'ok', 'yes')"><sx:sync version="1" id="E35jwf6PFUyIKPzqlZ8IhQ==" /></outline><outline text="At index 1, remove 1 item and add &quot;ok&quot; and &quot;yes&quot;."><sx:sync version="1" id="vUedMwGjDkyHbdm/Ncj1mw==" /></outline><outline text="// [1, 'ok', 'yes', 3, 4]"><sx:sync version="1" id="wSgAaAMrN0SrTaizC2rBkA==" /></outline><sx:sync version="1" id="cWlwb/4e/EC0XmdlEiDK5g==" /></outline><outline text="Returns array of deleted elements"><outline text="If one element removed, returns array of one."><sx:sync version="1" id="zQuogs2u7E+opkSmQayWhQ==" /></outline><outline text="If no elements removed, returns empty array."><sx:sync version="1" id="isssqltw/UWWZ13Sc9YkUA==" /></outline><sx:sync version="1" id="Tb+caFSx4E+GuM9RD72VEg==" /></outline><outline text="var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];&#xA;&#xA;// insert 'drum' at index 2&#xA;myFish.splice(2, 0, 'drum'); &#xA;&#xA;//  [&quot;angel&quot;, &quot;clown&quot;, &quot;drum&quot;, &quot;mandarin&quot;, &quot;sturgeon&quot;]&#xA;// returns [ ]&#xA;&#xA;// remove 1 item at index 2&#xA;myFish.splice(2, 1); &#xA;&#xA;//  [&quot;angel&quot;, &quot;clown&quot;, &quot;mandarin&quot;, &quot;sturgeon&quot;]&#xA;// returns [&quot;drum&quot;]"><sx:sync version="1" id="B8ipsSlkOU2mlC1snsm7jQ==" /></outline><outline text="splice() can do same as push()"><outline text="results.push(num[i]);"><sx:sync version="1" id="48xGFWU99k263hj0/BtuKQ==" /></outline><outline text="...is the same as..."><sx:sync version="1" id="1626Uoq6UUqVU0jZfYJM5A==" /></outline><outline text="results.splice( results.length, 0, num[i] )"><sx:sync version="1" id="3Rzb/4YgjkmH3lndArDDRA==" /></outline><outline text="function isEven(num) {&#xA;  var results = [];&#xA;  for (var i = 0; i &lt; num.length; i++) {&#xA;    if (num[i] % 2 === 0) {&#xA;      //results.push(num[i]);&#xA;      // ...is the same as ...&#xA;      results.splice(results.length,0,num[I]);&#xA;    }&#xA;  }&#xA;  return results;&#xA;}&#xA;&#xA;var output = isEven([1, 4, 5, 6, 10, 13]);&#xA;console.log(output); // --&gt; [4, 6, 10]"><sx:sync version="1" id="dEwSxf2aEUuZAwh+gWeHlQ==" /></outline><sx:sync version="1" id="14LWVXucVEebYqTwx3W7Sw==" /></outline><outline text="Examples"><sx:sync version="1" id="8mtF3I9g8U2eyblkoiunvA==" /></outline><sx:sync version="1" id="Z3yLsaTCLUqUbH6jfQfK2Q==" /></outline><outline text="slice(begin, end)"><outline text="Returns a sub-array."><sx:sync version="1" id="C80C4/aXV06KKzsTHoJJbg==" /></outline><outline text="- Array.slice() is like String.slice()."><sx:sync version="1" id="RI945pLxbUibxxsYKSGhRA==" /></outline><outline text="Begin index - included"><sx:sync version="1" id="oSAu+s2MgkiGVHJOomNZXg==" /></outline><outline text="End index - excluded"><sx:sync version="1" id="z7qmWYHUFk6w6R1RJVgeUQ==" /></outline><outline text="Example"><outline text="var fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango'];&#xA;var citrus = fruits.slice(1, 3);&#xA;&#xA;// fruits - ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']&#xA;// citrus - ['Orange','Lemon']"><sx:sync version="1" id="HhInEksPFUObXiMPSsw+zA==" /></outline><sx:sync version="1" id="0UlG10eKRkqWrPu0hNzysQ==" /></outline><outline text="Non-destructive version of .pop()"><outline text="var lastOne = ['a', 'k', 'j', 'x'].slice(-1);"><sx:sync version="1" id="sb8l8j08mEK+pqGmdZ9IAQ==" /></outline><outline text=".slice(0, -1); // same"><sx:sync version="1" id="IU5w17P970OSNOAo/YbRMw==" /></outline><sx:sync version="1" id="Pf89SaW4dEKcTCt2qa5EiQ==" /></outline><outline text="Easily copy an array"><outline text="let newArr = arr.slice(0)"><sx:sync version="1" id="qkaxwzMC5U+xJNeusGzx3g==" /></outline><outline text="Returns a shallow copy of the array"><sx:sync version="1" id="w0DODANUNkawtETfs6u4Ww==" /></outline><outline text="Strings, booleans, and numbers are copied by value, but objects are copied by reference."><sx:sync version="1" id="0XzfZqXAWESO+X0B7mNfqg==" /></outline><sx:sync version="1" id="/WAFGtr+8EG4P3RsNOvyWA==" /></outline><outline text="Delete third element of array"><outline text="Cowboy trick - Spread operator"><sx:sync version="1" id="bzHOb+gxRECnGg0RvXdM7Q==" /></outline><outline text="var items = [1, 2, 3, 4, 5]"><sx:sync version="1" id="7bpLYHmGzkGfLpPkDs7iIw==" /></outline><outline text="To remove item at index 3, do multiple spread and slice operations -"><sx:sync version="1" id="kA7PslFgfk6b8zohNReQmw==" /></outline><outline text="Take slice from index 0 to, but not including, index 2"><sx:sync version="1" id="3PqMR9SUR02M0rz+qdM0OQ==" /></outline><outline text="Take slice from index 3 to end"><sx:sync version="1" id="LDmhDiEpdUi4R/e0MNfKWg==" /></outline><outline text="[...items.slice(0, 2), ...items.slice(3)] // [1, 2, 4, 5]"><sx:sync version="1" id="nu6v8SrbxUu1FMjWRGYDcQ==" /></outline><sx:sync version="1" id="gsjTt/adVUiSXlCn4fDv8A==" /></outline><sx:sync version="1" id="Le+Xv1IucUCCJ/9dqN4VuA==" /></outline><outline text="concat(item[, itemN])"><outline text="concat() // push()"><outline text="let arr1 = ['a', 'b', 'c'];&#xA;let arr2 = ['d', 'e', 'f'];&#xA;&#xA;var arr3 = arr1.concat(arr2);&#xA;console.log(arr3); &#xA;&gt; [“a”, “b”, “c”, “d”, “e”, “f”]&#xA;&#xA;let arr4 = arr1.push(arr2);&#xA;console.log(arr4);&#xA;&gt; 4&#xA;console.log(arr1);&#xA;&gt; [“a”, “b”, “c”, [“d”, “e”, “f”]]"><sx:sync version="1" id="lwEXRa6cb0uvWiHDHAAUsQ==" /></outline><sx:sync version="1" id="MakWjNAxoEa+cjx6CzNS2w==" /></outline><outline text="Example - concat() + arguments"><outline text="function joinThreeArrays(arr1, arr2, arr3) {&#xA;  let result = [];&#xA;  for (let i = 0; i &lt; arguments.length; i++) {&#xA;    result = result.concat(arguments[i]);&#xA;  }&#xA;  return result;&#xA;}"><sx:sync version="1" id="QP46lmaO50uqbQ1t+FPkJA==" /></outline><sx:sync version="1" id="juukE37yV0y0e7Q79ijuog==" /></outline><outline text="// combine arrays&#xA;const array1 = ['a', 'b', 'c'];&#xA;const array2 = ['d', 'e', 'f'];&#xA;const array3 = array1.concat(array2);&#xA;&#xA;[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]"><sx:sync version="1" id="kHp4dEJmqUSrcDYwOQOq6w==" /></outline><outline text="// add values to array&#xA;const arr1 = ['a', 'b', 'c'];&#xA;const result = arr1.concat(1, [2, 3]);&#xA;&#xA;['a', 'b', 'c', 1, 2, 3]"><sx:sync version="1" id="5OnU6rPfz0+L0hfo1jRjyQ==" /></outline><outline text="Returns new array with items added"><sx:sync version="1" id="ZKn3YH1ITkeQBFim6snhAA==" /></outline><sx:sync version="1" id="mSFSb3juKkCc3Z9SAYXK5g==" /></outline><outline text="sort()"><outline text="Mutates the array"><sx:sync version="1" id="rMa2L5/jrEycFh44GEXs/g==" /></outline><outline text="Takes an optional comparison function."><sx:sync version="1" id="nEZ4T19IE06+xpR3o2ykRg==" /></outline><outline text="Example"><outline text="palindromes.sort(sortAscendingByLength);&#xA;&#xA;function sortAscendingByLength(a, b) {&#xA;  return a.length - b.length;&#xA;}"><sx:sync version="1" id="0jICbb2/ikeyLSIMj2WgIQ==" /></outline><sx:sync version="1" id="4D0uQKFZwE2RwrB7iYya4g==" /></outline><outline text="Doesn't work for numbers!"><outline text="Numbers are not sorted numerically. They are converted to unicode and then sorted by unicode order. So 10 comes before 2."><sx:sync version="1" id="kcCLGzQhuU2h5AhJ9J50jQ==" /></outline><sx:sync version="1" id="b7nKKkHG4UKGc6tNW2rHKQ==" /></outline><outline text="To sort numbers -"><outline text="// sort numbers&#xA;var numArray = [140000, 104, 99];&#xA;&#xA;numArray.sort(function(a, b) {&#xA;  return a - b;&#xA;});&#xA;&#xA;[ 99, 104, 140000 ]&#xA;// it just works"><sx:sync version="1" id="tj/Z8b4XP0SEKh4vrixKXA==" /></outline><sx:sync version="1" id="KsTf103l0EKte3pltRpBNQ==" /></outline><outline text="// Inline compare function&#xA;sort(function compareFn(elem1, elem2) { /* ... */ })"><sx:sync version="1" id="9NX6L30k/E2TJFq7kA2ljQ==" /></outline><outline text="Returns the sorted array"><sx:sync version="1" id="6XFwC8Mf3k+lJDFbc1Nsxw==" /></outline><sx:sync version="1" id="b88OeXST4UWN9I1Z9aNUIw==" /></outline><outline text="reverse()"><outline text="Mutates array"><sx:sync version="1" id="cV/fcTrGR0OkZyfaYwt2Zw==" /></outline><outline text="Returns the reversed array."><sx:sync version="1" id="jOKmZweSwUyRiryqHk/0sQ==" /></outline><sx:sync version="1" id="2N9/Nq1M40aSW8zG3y0u8g==" /></outline><outline text="toLocaleString()"><outline text="Returns a string with the toLocaleString() of each element separated by commas"><sx:sync version="1" id="Lamr2N19s0u2blRZa0u4tg==" /></outline><sx:sync version="1" id="snoXAoiT0kSpfzJCjKVD/A==" /></outline><outline text="toString()"><outline text="Returns a string with the toString() of each element separated by commas"><sx:sync version="1" id="SYqpxe3uwU+YZ9RYDbL6VA==" /></outline><outline text="- Each item has its toString() method called, and the string equivalent of each item is added to the finalresult - a comma separated string."><sx:sync version="1" id="4fAb1sWDEEyHMIuKhYfRLQ==" /></outline><sx:sync version="1" id="S9jOLxlQ8kicfey0fo1qbw==" /></outline><outline text=".includes()"><outline text="checks whether a given value exists in the array"><sx:sync version="1" id="dH4n5mRUU0ic3ahxtxlTDg==" /></outline><outline text="Returns boolean"><sx:sync version="1" id="1Zi4Be0gsU2OJhmlztqA+Q==" /></outline><sx:sync version="1" id="K9lFx7t9KEqv3VekssBfbw==" /></outline><outline text="valueOf()"><outline text="Returns a string, number, or Boolean equivalent of the object."><sx:sync version="1" id="ZQNL39DKNU+2NM0eNqygBQ==" /></outline><outline text="- Often returns the same value as &quot;toString&quot;."><sx:sync version="1" id="dlY+xKm1PECdpJ6n8+lJ7w==" /></outline><sx:sync version="1" id="R7o7QM46oEqojzvIqa/ofQ==" /></outline><outline text="every()"><outline text="function isBigEnough(element, index, array) {&#xA;  return element &gt;= 10;&#xA;}&#xA;[12, 5, 8, 130, 44].every(isBigEnough);   // false&#xA;[12, 54, 18, 130, 44].every(isBigEnough); // true"><sx:sync version="1" id="wWmBWD0i906y6NYGMUO6YQ==" /></outline><outline text="var data = [&#xA;    {userID: 1, name: &quot;Ryan&quot;, groups: [&quot;dev&quot;, &quot;ops&quot;, &quot;qa&quot;, &quot;employee&quot;]},&#xA;    {userID: 2, name: &quot;Bob&quot;, groups: [&quot;ops&quot;, &quot;employee&quot;]},&#xA;    {userID: 3, name: &quot;John&quot;, groups: [&quot;qa&quot;, &quot;employee&quot;]},&#xA;    {userID: 4, name: &quot;Paul&quot;, groups: [&quot;dev&quot;, &quot;qa&quot;, &quot;employee&quot;]}&#xA;];&#xA;&#xA;var isDev = function (user) {&#xA;    return user.groups.includes(&quot;dev&quot;);&#xA;};&#xA;&#xA;var isEmployee = function(user) {&#xA;    return user.groups.includes(&quot;employee&quot;);   &#xA;};&#xA;&#xA;var isManager = function(user) {&#xA;    return user.groups.includes(&quot;manager&quot;);   &#xA;};&#xA;&#xA;data.every(isDev);      // false, not everyone is a dev&#xA;data.every(isEmployee); // true, everyone is an employee&#xA;data.some(isDev);       // true, at least one user is a dev&#xA;data.some(isManager);   // false, no user is a manager"><sx:sync version="1" id="UrYPT6e9F0+WPSC25DxbIg==" /></outline><sx:sync version="1" id="0iDEXgCmckGYa+r1kDJW2g==" /></outline><outline text="some()"><outline text="See example for every()"><sx:sync version="1" id="L8mxCeTZpUeP/BV7P9I1wQ==" /></outline><sx:sync version="1" id="oOMUsd6ZkEWXV66+hCKGaw==" /></outline><outline text="Swap array elements"><outline text="- one temporary variable is enough"><sx:sync version="1" id="B5o9NLyK7U+ZgS9wuRhgwQ==" /></outline><outline text="var temp = list[y];&#xA;list[y] = list[x];&#xA;list[x] = temp;"><sx:sync version="1" id="lu6qDrKfaEiFuAW7sbv59w==" /></outline><sx:sync version="1" id="msGetgEveUe5FSR0TrU2Aw==" /></outline><outline text="map()"><outline text="Return value"><outline text="- New array of same size as original"><sx:sync version="1" id="A9tc0rTGbUqqBib0jukMBg==" /></outline><outline text="- New array with each element being the result of callback"><sx:sync version="1" id="5H5SdvC0+U+no+n5QqI5Ag==" /></outline><outline text="- map() must have return statement or   all elements will be undefined"><sx:sync version="1" id="0xCyE8v3q0OmoNNHybAvrg==" /></outline><sx:sync version="1" id="cJWgj/kfW0yoXIUx7AmYzQ==" /></outline><outline text="- applies a function to each element of original array "><sx:sync version="1" id="+OHF8OutlUeXF4o6e9AS9g==" /></outline><outline text="- return value of callback is added to new array"><sx:sync version="1" id="yJjH35Tm9EOwPN8S3kun1w==" /></outline><outline text="- Transform each element and push it to new array"><sx:sync version="1" id="L7BODckKVEWhqZvhNevtBw==" /></outline><outline text=".map(function(i) {return i * i;});"><outline text="- accepts a function as a parameter"><sx:sync version="1" id="JbVlw+bVy02TndrYCiDY7w==" /></outline><outline text="- passes each element to the function"><sx:sync version="1" id="TjdmBsFdZke6yTeCvqCP/Q==" /></outline><outline text="- projects each element's transformed value into results array"><sx:sync version="1" id="jiPxwRz72kWzS9lGvO8BnQ==" /></outline><outline text="- returns results array"><sx:sync version="1" id="eptKcGpG/028W8UotyShUg==" /></outline><outline text="- original array is unchanged"><sx:sync version="1" id="QY0OtAzSFESYJpKKTmyA0w==" /></outline><outline text="function AreaOfCircle(radius) {  &#xA;    var area = Math.PI * (radius * radius);  &#xA;    return area.toFixed(0);  &#xA;}  &#xA; &#xA;var radii = [10, 20, 30];  &#xA;&#xA;// Get the areas from the radii.&#xA;  &#xA;var areas = radii.map(AreaOfCircle);  &#xA;&#xA;console.log(areas);  &#xA;  &#xA;// 314,1257,2827"><sx:sync version="1" id="qELD+v1If0aLfQ6oU6Creg==" /></outline><outline text="illustrates use of thisArg argument, which specifies an object to which the this keyword can refer."><sx:sync version="1" id="Nj0s4OtlEEqh8/HKmSdWdg==" /></outline><outline text=" var obj = {  &#xA;    divisor: 10,  &#xA;    remainder: function (value) {  &#xA;        return value % this.divisor;  &#xA;    }  &#xA;}  &#xA; &#xA;var numbers = [6, 12, 25, 30];  &#xA;&#xA;// Get remainders -  &#xA;// obj argument specifies the this value in callback function.  &#xA;var result = numbers.map(obj.remainder, obj);  &#xA;console.log(result);  &#xA;  &#xA;// 6,2,5,0  "><sx:sync version="1" id="eM899zeLQUeQApZ4Ig4IPA==" /></outline><outline text="// Pass in global function -&#xA;var numbers = [9, 16];  &#xA;var result = numbers.map(Math.sqrt);  &#xA;&#xA;console.log(result);  &#xA;// 3,4  "><sx:sync version="1" id="1ZxEHgPLZE+5EoaCN8UrSg==" /></outline><outline text="Also works for strings - "><sx:sync version="1" id="fo4xnB/oZEyPjmCwJHx7fA==" /></outline><outline text="// callback fn - makes substring of prev, cur, and next char &#xA;function threeChars(value, index, str) { &#xA;    return str.substring(index - 1, index + 2);  &#xA;}  &#xA; &#xA;var word = &quot;Thursday&quot;;  &#xA;var result = [].map.call(word, threeChars);&#xA;&#xA;// Alternate syntax -    &#xA;// var result = Array.prototype.map.call(word, threeChars);&#xA;  &#xA;// Each result consists of previous, current, and next char&#xA;console.log(result);  &#xA;// Th,Thu,hur,urs,rsd,sda,day,ay  "><sx:sync version="1" id="o7anGEe8pU+pTJeUVTbQYw==" /></outline><outline text="map() with arrow function -"><sx:sync version="1" id="Sq2kb6qV9UyI+KWvH7OABg==" /></outline><outline text="let animal_names = animals.map((animal, index, animals) =&gt; {&#xA;    return animal.name&#xA;})"><sx:sync version="1" id="C7gBuDA5TkqaGhmSuuRFxQ==" /></outline><outline text="Helper function can take idx as parameter -"><outline text="function (element [, index] [, collection])"><sx:sync version="1" id="ma/YC/ZFyEaInf8E01y9oQ==" /></outline><sx:sync version="1" id="02KLW1ZLJUGWG+CEzcHTNA==" /></outline><sx:sync version="1" id="njDQMRwzdkeDgejTF+zU4w==" /></outline><outline text="Higher order functions are chainable - "><outline text="data.filter(...).filter(...).map(...).map(...)"><sx:sync version="1" id="4rc1vqkbFkWk1iMFz6EYqw==" /></outline><sx:sync version="1" id="LDAEbEQrvkWhqQDGodypeg==" /></outline><outline text="var arr = [1, 2, 3, 4];&#xA;&#xA;var squares = arr.map(function(elem) {&#xA;  return elem * elem;&#xA;});&#xA;&#xA;console.log(squares); // [1, 4, 9, 16]"><sx:sync version="1" id="ORI9areWvEKf01aIRg+5gg==" /></outline><outline text="equivalent using for..of -"><outline text="var arr = [1, 2, 3, 4];&#xA;&#xA;var squares = [];&#xA;&#xA;for (var element of arr) {&#xA;  squares.push(element * element);&#xA;}&#xA;&#xA;console.log(squares); // [1, 4, 9, 16]"><sx:sync version="1" id="P3RgjOeLpUChfjahvCPwsA==" /></outline><sx:sync version="1" id="G1wU69bf5kuwwkQPSwzyyA==" /></outline><outline text="Parameters to callback function"><outline text="currentValue - value of current element from array"><sx:sync version="1" id="gzb9ySZwz0CAGS1wYqCPcw==" /></outline><outline text="index - index of the current element from array"><sx:sync version="1" id="y10khAl4WUukgbH2Aytvsg==" /></outline><outline text="array - array that map() was called upon "><sx:sync version="1" id="UWh8x4ZIVUep4Qo9cAL9wA==" /></outline><sx:sync version="1" id="Be+S0ElRtUO/hcRn+rfGkQ==" /></outline><outline text="thisArg"><outline text="Value to use as this when executing callback"><sx:sync version="1" id="AHINs4hq10eMJG2d+WsvAw==" /></outline><sx:sync version="1" id="vGcHGX9N+0u0OFD1Cz7YOQ==" /></outline><outline text="Use cases -"><outline text="Format complex data for output"><sx:sync version="1" id="1a237y3euk6i0nOK1deUPw==" /></outline><outline text="Pluck bits of data from a complicated structure"><sx:sync version="1" id="qQXpZ/wWg0qHMvM2/6xXCg==" /></outline><sx:sync version="1" id="eCuFR9aC/UaXbmXRqkgd8g==" /></outline><sx:sync version="1" id="bD5WaQc7vkOtuSDu7Gz47w==" /></outline><outline text="filter()"><outline text="Applies a function to each element of an array."><sx:sync version="1" id="GGZMvmQpEUuUIywi0uX7/A==" /></outline><outline text=".filter(function(i) {return i % 2 == 0});"><sx:sync version="1" id="GaQCCeS7LUKD0R07X2jKJw==" /></outline><outline text="Passes each element in turn to the function provided."><sx:sync version="1" id="EO2HoMPQOkuceLRvH8nExw==" /></outline><outline text="- If helper function returns true, pushes current element into new array."><sx:sync version="1" id="MwJ0OOgJsEGABsCZAOWgVw==" /></outline><outline text="- if function returns false, that element is not added to new array"><sx:sync version="1" id="1UjWqkCzGEa30b+7OfUs3w==" /></outline><outline text="Returns new array with length &lt;= old array length "><sx:sync version="1" id="DwRD5PsP/0C17vp+nqDzsg==" /></outline><outline text="Returns array of elements that evaluated to true"><sx:sync version="1" id="shDWmZl9UkKrItUj8MUUZQ==" /></outline><outline text="Helper function must return boolean"><sx:sync version="1" id="qqNBxNldgkOAmTrYPbMLIA==" /></outline><outline text="var arr = [1, 2, 3, 4];&#xA;var odds = arr.filter(function(element) {&#xA; return element % 2 !== 0;&#xA;});&#xA;console.log(odds); // [1, 3]"><sx:sync version="1" id="eDFO7gNiIEKFVJhaZBbtAw==" /></outline><outline text="Subtract an array from an array -"><outline text="const A = [1, 4, 3, 2]&#xA;const B = [0, 2, 1, 2]&#xA;console.log(A.filter(n =&gt; !B.includes(n)))&#xA;// [ 4, 3 ]"><sx:sync version="1" id="zCyXApCwuUy7ro5QqnTcnw==" /></outline><sx:sync version="1" id="hNkNcmWRSkW3p1ZEXoVKng==" /></outline><outline text="Equivalent - for..of loop -"><outline text="var arr = [1, 2, 3, 4];&#xA;var odds = [];&#xA;for (var element of arr) {&#xA; if (num % 2 !== 0) {&#xA;  odds.push(element);&#xA; }&#xA;}&#xA;console.log(odds); // [1, 3]"><sx:sync version="1" id="6RpJH4IF7kGCFBj+noemgw==" /></outline><sx:sync version="1" id="uCrTGE1CZ0utL3DEmeuHEg==" /></outline><outline text="Batman example -"><outline text="var sidekicks = [&#xA;    { name: &quot;Robin&quot;,     hero: &quot;Batman&quot;   },&#xA;    { name: &quot;Supergirl&quot;, hero: &quot;Superman&quot; },&#xA;    { name: &quot;Oracle&quot;,    hero: &quot;Batman&quot;   },&#xA;    { name: &quot;Krypto&quot;,    hero: &quot;Superman&quot; }&#xA;];"><sx:sync version="1" id="bBDH9ElhJkGH/oSbnmdEtw==" /></outline><outline text="Notice the cool chaining action -"><sx:sync version="1" id="ph+fHj/XHU6k3h9hWuENVQ==" /></outline><outline text="var sortedBatKickNames = sidekicks.filter(function (el) {&#xA;    return (el.hero === &quot;Batman&quot;);&#xA;}).map(function(el) {&#xA;    return el.name;&#xA;}).sort();&#xA;&#xA;// Output: [&quot;Oracle&quot;, &quot;Robin&quot;];&#xA;console.log(sortedBatKickNames);"><sx:sync version="1" id="lBkIz3hFkUaqyZg50n/sQg==" /></outline><sx:sync version="1" id="5piDUn2gBk2oHd3yi1BRBA==" /></outline><outline text="filter() with arrow function"><outline text="let small_animals = animals.filter((animal) =&gt; {&#xA;    return animal.size === &quot;small&quot;&#xA;})"><sx:sync version="1" id="S5Ww0WNKCUColpseHOmD9w==" /></outline><sx:sync version="1" id="kXLiWdfMF0WkpTNClMrS1A==" /></outline><outline text="Cullen's food filter"><outline text="let foods = [&#xA;  {&#xA;    name: 'burger', &#xA;    ingredients: [&#xA;      'beef', 'bun', 'lettuce', 'ketchup'&#xA;    ]&#xA;  },&#xA;  {&#xA;    name: 'fries', &#xA;    ingredients: [&#xA;      'potatoes', 'oil'&#xA;    ]&#xA;  },&#xA;  {&#xA;    name: 'chicken sandwich', &#xA;    ingredients: [&#xA;      'chicken', 'lettuce', 'mayo', 'bun'&#xA;    ]&#xA;  },&#xA;  {&#xA;    name: 'tea', &#xA;    ingredients: [&#xA;      'tea'&#xA;    ]&#xA;  },&#xA;  {&#xA;    name: 'veggie burger', &#xA;    ingredients: [&#xA;      'veggies', 'bun'&#xA;    ]&#xA;  },&#xA;  {&#xA;    name: 'veggie burger', &#xA;    ingredients: [&#xA;      'veggies', 'bun'&#xA;    ]&#xA;  },&#xA;  {&#xA;    name: 'pancakes', &#xA;    ingredients: [&#xA;      'wheat', 'syrup'&#xA;    ]&#xA;  }&#xA;]"><sx:sync version="1" id="qmnkUySc3UCKr7B6/aSx9g==" /></outline><outline text="function foodFilter(arrIn, strFood)&#xA;{&#xA;return arrIn.filter(food=&gt;{&#xA;  for(item of food['ingredients'])&#xA;  {&#xA;    if(item==strFood)&#xA;    {&#xA;      return;&#xA;    }&#xA;  }&#xA;  return food;&#xA;})&#xA;}&#xA;&#xA;function veggieFoodFilter(foodIn) {&#xA;  let retVeg =[];&#xA;  foodFilter(foodFilter(foodIn, 'chicken'), 'beef').forEach(x=&gt; retVeg.push(x.name))&#xA;  return retVeg;&#xA;}&#xA;&#xA;console.log(veggieFoodFilter(foods));"><sx:sync version="1" id="a/7e1JBFvEqT0wFnrJjZ7A==" /></outline><sx:sync version="1" id="VRWIw56yaUqx1HIxHK3gKA==" /></outline><outline text="Examples"><outline text="This function -"><outline text="- takes an array and an object"><sx:sync version="1" id="oGx/wJBC90Oolxxc+GFRkg==" /></outline><outline text="- returns a new object whose properties are those in the object AND whose keys are present in the array."><sx:sync version="1" id="dAQyDmG8Y0+Tv86rFzDbDQ==" /></outline><outline text="- ignores keys that are in the given array but not in the given object."><sx:sync version="1" id="xYTimfq5akyNBB/ScYINzw==" /></outline><outline text="- doesn't modify the passed-in object"><sx:sync version="1" id="3qcmaj3CdECIGSK1zLK6ww==" /></outline><sx:sync version="1" id="6g1oSkBpwE60Kmdd/Mae/w==" /></outline><outline text="function select(arr, obj) {&#xA;  let output = {};&#xA;  let hits = arr.filter(function(elem) {&#xA;    return elem in obj; &#xA;  });&#xA;  for(let i = 0; i &lt; hits.length; i++) {&#xA;    output[hits[i]] = obj[hits[i]];&#xA;  }&#xA;  return output;&#xA;}&#xA;&#xA;var arr = ['a', 'c', 'e'];&#xA;var obj = {&#xA;  a: 1,&#xA;  b: 2,&#xA;  c: 3,&#xA;  d: 4&#xA;};&#xA;var output = select(arr, obj);&#xA;console.log(output); // --&gt; { a: 1, c: 3 }"><sx:sync version="1" id="X/LJxAoSQ0mSuRURPrZABA==" /></outline><sx:sync version="1" id="TAoEXFpq8E+RQlwehCHtew==" /></outline><outline text="Remove duplicates from array of objects"><outline text="Preserves order"><sx:sync version="1" id="8mvF//Vwckqm1sg7gSZZnQ==" /></outline><outline text="Find unique id's in an array."><sx:sync version="1" id="xGXEczTSbEmEZtGXZAaf+w==" /></outline><outline text="arr.filter((v,i,a)=&gt;a.findIndex(v2=&gt;(v2.id===v.id))===i)"><sx:sync version="1" id="dFVh6GNyg0KvI1wBtDkTBg==" /></outline><outline text="If the order is not important, map solutions are faster"><sx:sync version="1" id="ukhP2IB+d0e+nOyORnp++Q==" /></outline><sx:sync version="1" id="Ix50yRDxI0OVLLlMWef8Mw==" /></outline><sx:sync version="1" id="K3BrKsYigUiHttkrogu0xw==" /></outline><outline text="reduce()"><outline text="About"><outline text="- multi-tool"><sx:sync version="1" id="MFQkYPRK8Ui8WvWCZ9YX7w==" /></outline><outline text="- return value from reducer function always becomes initial value for next iteration"><sx:sync version="1" id="/CvTJW9DtkyWhQ2mzX9XSg==" /></outline><outline text="Running total is passed into acc (first param), and each element of array is passed into elem (second param)."><outline text="1st param"><outline text="Previous value / accumulator / running total / result"><sx:sync version="1" id="kEjnBQ4YB06+RYZqUrJsew==" /></outline><sx:sync version="1" id="xOdM6RansE+6AOljs1Z7CQ==" /></outline><outline text="2nd param"><outline text="Current element of array"><sx:sync version="1" id="wWFWJGqt50mEbBMVrlwmLg==" /></outline><sx:sync version="1" id="YgZErSFQNkuw9CoC4VOWJg==" /></outline><outline text="3rd param"><outline text="Index"><sx:sync version="1" id="Asbx7F3s8k+d66z4B5qhJg==" /></outline><sx:sync version="1" id="c5o4LJcdK0Cznkd3WwRphw==" /></outline><outline text="4th param"><outline text="Array being traversed"><sx:sync version="1" id="gnMqcJB7HECw20XswSJOhw==" /></outline><sx:sync version="1" id="mHvtJnGg6U6i7FCbqBnKbg==" /></outline><outline text="Final param - after callback"><outline text="Initial value"><sx:sync version="1" id="66NHkcQS9UeajSAbjhKbYg==" /></outline><outline text="Optional"><sx:sync version="1" id="rRe8QhVOC06HDYEObj311A==" /></outline><outline text="Starting point for first iteration"><sx:sync version="1" id="zdkqZphmQEavfhTw5HQlRg==" /></outline><sx:sync version="1" id="h9VeWwl8p06B773flS4yyQ==" /></outline><sx:sync version="1" id="0r9YNBJcJUiKkmptdS9x8A==" /></outline><outline text="Required - must return value from callback"><sx:sync version="1" id="I9WbembF3EOnYEXDCzaglA==" /></outline><sx:sync version="1" id="h5CrgCnfX0qHgZXgF9lC/w==" /></outline><outline text="Syntax -"><outline text="arr.reduce(callback[, initialValue])"><sx:sync version="1" id="eY/sXhkDRUOQ+Ut23lDEEw==" /></outline><outline text="arr.reduce(cbk(acc, curValue[, idx[, array]])[, initialValue])"><sx:sync version="1" id="gCjycZoFW0WDQuheDQ8HzA==" /></outline><outline text="What callback does -"><outline text="- Take in accumulator and current element"><sx:sync version="1" id="oF9qeIIFPUKE0ZjURYJ4fg==" /></outline><outline text="- Reduce input to one value"><sx:sync version="1" id="jA6aQtQxY0ajvijLsfovkQ==" /></outline><outline text="- Return that value"><sx:sync version="1" id="HvFaP/XuR02BgPvXJvoMUg==" /></outline><sx:sync version="1" id="G3zH3gW2XUqAPg8YiS7fBA==" /></outline><outline text=".reduce() // arrow function"><outline text="let sum = arr.reduce((acc, elem, idx, arr) =&gt; {&#xA;    return acc += elem&#xA;}, 0)"><sx:sync version="1" id="CHOU6pj2zUmaJ35votwMIA==" /></outline><sx:sync version="1" id="m3EhMl7jskaVi2/m3mo6qg==" /></outline><outline text="Returns result from reduction"><sx:sync version="1" id="ZmfAHJgMK0KfA5cMTJBdMA==" /></outline><outline text="Syntax signatures"><outline text="reduce((previousValue, currentValue) =&gt; { /* … */ } )&#xA;reduce((previousValue, currentValue, currentIndex) =&gt; { /* … */ } )&#xA;reduce((previousValue, currentValue, currentIndex, array) =&gt; { /* … */ } )&#xA;&#xA;reduce((previousValue, currentValue) =&gt; { /* … */ } , initialValue)&#xA;reduce((previousValue, currentValue, currentIndex) =&gt; { /* … */ } , initialValue)&#xA;reduce((previousValue, currentValue, currentIndex, array) =&gt; { /* … */ }, initialValue)"><sx:sync version="1" id="6NmZiW56JUyV9v49hScmzg==" /></outline><sx:sync version="1" id="mAbxI9yftEOJ41pQfgbJxw==" /></outline><outline text="Parameters"><outline text="callbackFn"><outline text="- &quot;reducer&quot; function called with the following arguments:"><sx:sync version="1" id="l/h+HJLiQEKeNYUZL//taQ==" /></outline><sx:sync version="1" id="sXRHadFLfUeKaZ6ZcT0h+w==" /></outline><outline text="previousValue"><outline text="- value resulting from the previous call to callbackFn. On first call, initialValue if specified, otherwise value of array[0]"><sx:sync version="1" id="6CKYOMvfhEKbDBxdtZYHlQ==" /></outline><sx:sync version="1" id="kGOpchb2oU2y8KFZdPbZIg==" /></outline><outline text="currentValue"><outline text="- value of current element. On first call, value of array[0] if initialValue was specified, otherwise value of array[1]"><sx:sync version="1" id="i96ji22Od0OsZgRapw28tw==" /></outline><sx:sync version="1" id="LU4UVlSKlESHwmVb4/lXkQ==" /></outline><outline text="currentIndex"><outline text="- index of currentValue in array. On first call, 0 if initialValue was specified, otherwise 1"><sx:sync version="1" id="1HVazcf5xEOSrNjhEwzSOg==" /></outline><sx:sync version="1" id="gYycaYA/+Uuu7CgRys1x0g==" /></outline><outline text="array"><outline text="- array being traversed"><sx:sync version="1" id="8fh35EDocEuCw+oPhBRjBw==" /></outline><sx:sync version="1" id="Et+E3WXMUkyHz1QDEWUWsw==" /></outline><outline text="initialValue"><outline text="Optional"><sx:sync version="1" id="8818663ACUaziQnjE/XlrA==" /></outline><outline text="- value to which previousValue is initialized the first time callback is called. If initialValue is specified, that also causes currentValue to be initialized to the first value in the array. If initialValue is not specified, previousValue is initialized to first value in the array, and currentValue is initialized to second value in the array."><sx:sync version="1" id="9Cy+SryxU0mMAXW+X7EjtA==" /></outline><sx:sync version="1" id="r+tBYeDExEC30Gip/7OMPQ==" /></outline><sx:sync version="1" id="Q6YqJJ7Qk0SAhXfj9MkXxg==" /></outline><outline text="Return value"><outline text="- value that results from running reducer function to completion over entire array"><sx:sync version="1" id="2ZjGyMPZ1kW8Rrw69shkLg==" /></outline><sx:sync version="1" id="t/rF7s//vEqzTVEnYiUvvQ==" /></outline><sx:sync version="1" id="Xn/jMADrUUyK3rW8N/XqIg==" /></outline><outline text="Compare reduce / filter / forEach"><outline text="Write function that takes array of strings, and returns array containing only elements with odd numbered length"><sx:sync version="1" id="fvytvgrImU6c4GAsFFguOA==" /></outline><outline text="function filterOddLengthWords(words) {&#xA;  return words.reduce(function(result, word){&#xA;    if (word.length % 2 === 1) {&#xA;      result.push(word);&#xA;    }&#xA;    return result;&#xA;  }, []);  &#xA;}"><sx:sync version="1" id="FNJKvQ4BJkGLL+1163QSUA==" /></outline><outline text="function filterOddLengthWords(words) {&#xA;  return words.filter(function(word) {&#xA;    return word.length % 2 === 1;&#xA;  });&#xA;}"><sx:sync version="1" id="bE4Uncz9fE6NtEgUoklXag==" /></outline><outline text="function filterOddLengthWords(words) {&#xA;  var result = [];&#xA;  words.forEach(function(word) {&#xA;    if (word.length % 2 === 1) {&#xA;      result.push(word);&#xA;    }&#xA;  })&#xA;  return result;  &#xA;}"><sx:sync version="1" id="sKnMpsB/DU6SkQj0ORIynA==" /></outline><sx:sync version="1" id="7BeR5Uij/0WUgdUOk9eSxA==" /></outline><outline text="Compare reduce / for loop / for...of / forEach - see forEach() branch"><sx:sync version="1" id="PVjStofXY0+thyGnO5Fr8g==" /></outline><outline text="Use cases"><outline text="Find minimum number"><outline text="var arr = [100,250,50,300,450];&#xA;var min = function(a, b) {&#xA;    return Math.min(a, b);  &#xA;};    &#xA;arr.reduce(min);&#xA;//50"><sx:sync version="1" id="MSEmAmb9OUGxU7n3gMAoCw==" /></outline><outline text="Alternative -"><sx:sync version="1" id="8yezGDe9KEmuU/YrMcI/zg==" /></outline><outline text="Math.min(...arr)"><sx:sync version="1" id="HZnPG+1YH0Wb5RzDz/4Mwg==" /></outline><outline text="Math.max(...arr)"><sx:sync version="1" id="4gxZzVRDW0eY6lsdMYNSPQ==" /></outline><sx:sync version="1" id="QnymxCV84EaB7O0M1ltOSQ==" /></outline><outline text="Sum numbers "><outline text="var arr = [1, 2, 3, 4];&#xA;&#xA;var sum = arr.reduce(function(acc, elem) {&#xA;  return acc + elem;&#xA;}, 0);&#xA;// 10"><sx:sync version="1" id="kTSUXlYwikCeUm0gF5w7xw==" /></outline><outline text="// for array of objects&#xA;let total_weight = animals.reduce((weight, animal, index, animals) =&gt; {&#xA;    return weight += animal.weight&#xA;}, 0)"><sx:sync version="1" id="hRIuwTVLRUmCpAtYE4J67w==" /></outline><outline text="Initial value of result is 0 for addition"><sx:sync version="1" id="SE/aWkEFokWIe4kkwHZZjw==" /></outline><sx:sync version="1" id="m2GuVPx6LkyoML7TyNUgOA==" /></outline><outline text="Multiply numbers"><outline text="var product = arr.reduce(function(result, elem) {&#xA;  return result * elem;&#xA;}, 1);"><sx:sync version="1" id="Ap32DrHqk0S+OujIxwJEpg==" /></outline><outline text="console.log(product); // 24"><sx:sync version="1" id="8Dln5TtGUU+HrXX+zzcNgA==" /></outline><outline text="Initial value is 1 for multiplication"><sx:sync version="1" id="c2HeEfTXDkqACtB5SJhkDw==" /></outline><sx:sync version="1" id="8oPiG4z58062UyCpcvf2FQ==" /></outline><outline text="Count instances of words"><outline text="reduce()"><outline text="function countWords(str) {&#xA;  let words = str.split(' ');&#xA;  if (words.length === 0 || words[0] === '') {&#xA;    return { };&#xA;  }&#xA;  let countedWords = words.reduce(function (allWords, word) {&#xA;    if (word in allWords) {&#xA;      allWords[word]++;&#xA;    }&#xA;    else {&#xA;      allWords[word] = 1;&#xA;    }&#xA;    return allWords&#xA;  }, { });&#xA;  return countedWords;&#xA;}"><sx:sync version="1" id="bTe/pIu6+kS5dcutFcuWng==" /></outline><sx:sync version="1" id="SJQmhIy9gUaBB7mu2e1hWg==" /></outline><outline text="for loop"><outline text="function countWords(str) { &#xA;  // input: string of words (assume that the words are ONLY separated by a space)&#xA;  // output: object, where each key is a word &#xA;  //         and it's value is number of times it occurs in input string&#xA;&#xA;  // split input string into array of words&#xA;  // iterate through array&#xA;    // if current word doesn't exist in results object&#xA;      // add current word as a key&#xA;      // lets assign it the value 0&#xA;    &#xA;    // increment count of that word&#xA;  // return result object&#xA;  var results = {}; &#xA;&#xA;  if (str.length === 0) {&#xA;    return results;&#xA;  }&#xA;&#xA;  var allTheWords = str.split(&quot; &quot;); // [ask, a, bunch, get, a, bunch]&#xA;  for (var i = 0; i &lt; allTheWords.length; i++) {&#xA;    var currentWord = allTheWords[i]; // &quot;ask&quot;&#xA;    if (results[currentWord] === undefined) { // results[&quot;ask&quot;] === undefined &lt;-- true&#xA;      results[currentWord] = 0; // results[&quot;ask&quot;] = 0; --&gt; {ask: 0}&#xA;    } &#xA;    results[currentWord] += 1; // results[&quot;ask&quot;] == 1; &#xA;    // {ask: 1, a: 1} &lt;-- after our 2nd loop&#xA;  }&#xA;  return results;&#xA;}"><sx:sync version="1" id="Nux4iNEFQU2gVnbRICltcA==" /></outline><sx:sync version="1" id="mPeRd3/lBUiu+j4uwrvLQQ==" /></outline><sx:sync version="1" id="PflLgPkvb0KL1Ngu3f1w8A==" /></outline><sx:sync version="1" id="jHauImEjEki8W4JpGvvCLg==" /></outline><outline text="reduce()  map() // returns larger array -"><outline text="var data = [&#xA;    {userID: 1, name: &quot;Ryan&quot;, groups: [&quot;dev&quot;, &quot;ops&quot;, &quot;qa&quot;, &quot;employee&quot;]},&#xA;    {userID: 2, name: &quot;Bob&quot;, groups: [&quot;ops&quot;, &quot;employee&quot;]}&#xA;];&#xA;&#xA;//just creating this for clarity later&#xA;function arrayMerge (arrayOne, arrayTwo) {&#xA;    Array.prototype.push.apply(arrayOne, arrayTwo);&#xA;    return arrayOne;&#xA;}&#xA;&#xA;data.reduce(function(acc, user) {&#xA;    return arrayMerge(acc, user.groups.map(function(group) {&#xA;        return {name: user.name, group: group};&#xA;    }));&#xA;}, []);&#xA;/*&#xA;[&#xA;{name:&quot;Ryan&quot;,group:&quot;dev&quot;},&#xA;{name:&quot;Ryan&quot;,group:&quot;ops&quot;},&#xA;{name:&quot;Ryan&quot;,group:&quot;qa&quot;},&#xA;{name:&quot;Ryan&quot;,group:&quot;employee&quot;},&#xA;{name:&quot;Bob&quot;,group:&quot;ops&quot;},&#xA;{name:&quot;Bob&quot;,group:&quot;employee&quot;}&#xA;]&#xA;*/"><sx:sync version="1" id="mR7c9Cc5kUOVYunxsFHCSA==" /></outline><sx:sync version="1" id="UgRtM/eHq0SJaLEDsSCUKw==" /></outline><outline text="implement map() as reduce"><outline text="Re-implementation examples show power of reduce - but don't use reduce for everything "><sx:sync version="1" id="gjsXKknKF0a0M8GvS1HaUA==" /></outline><outline text="var data = [&#xA;    {id: 1, firstName: &quot;Ryan&quot;, lastName: &quot;Guill&quot;, email: &quot;ryanguill@gmail.com&quot;},&#xA;    {id: 2, firstName: &quot;John&quot;, lastName: &quot;Doe&quot;, email: &quot;johndoe@example.com&quot;},&#xA;    {id: 3, firstName: &quot;Mary&quot;, lastName: &quot;Smith&quot;, email: &quot;marysmith@example.com&quot;}&#xA;];&#xA;&#xA;var toFieldFormat = function(item) {&#xA;    return item.firstName + &quot; &quot; + item.lastName + &quot; &lt;&quot; + item.email + &quot;&gt;&quot;; &#xA;};&#xA;data.reduce(function(arr, item) {&#xA;   arr.push(toFieldFormat(item));&#xA;   return arr;&#xA;}, []).join(&quot;, &quot;); "><sx:sync version="1" id="DDf9mYxdl02aB+14ZKP/VA==" /></outline><sx:sync version="1" id="nu1givrWz0ml3lAp2cPMEQ==" /></outline><outline text="Implement filter() as reduce"><outline text="var data = [&#xA;    {userID: 1, name: &quot;Ryan&quot;, groups: [&quot;dev&quot;, &quot;ops&quot;, &quot;qa&quot;, &quot;employee&quot;]},&#xA;    {userID: 2, name: &quot;Bob&quot;, groups: [&quot;ops&quot;, &quot;employee&quot;]},&#xA;    {userID: 3, name: &quot;John&quot;, groups: [&quot;qa&quot;, &quot;employee&quot;]},&#xA;    {userID: 4, name: &quot;Paul&quot;, groups: [&quot;dev&quot;, &quot;qa&quot;, &quot;employee&quot;]}&#xA;];&#xA;&#xA;var isDev = function (user) {&#xA;    return user.groups.includes(&quot;dev&quot;);&#xA;};&#xA;data.reduce(function(arr, user){&#xA;    if (isDev(user)) {&#xA;        arr.push(user);&#xA;    }&#xA;    return arr;    &#xA;}, []);&#xA;&#xA;/*[{userID: 1, name: &quot;Ryan&quot;, groups: [&quot;dev&quot;, &quot;ops&quot;, &quot;qa&quot;]}, &#xA;   {userID: 4, name: &quot;Paul&quot;, groups: [&quot;dev&quot;, &quot;qa&quot;]}]*/"><sx:sync version="1" id="VzoJRlKD10KC/ESpHPCBKA==" /></outline><sx:sync version="1" id="Knqs6w5SLEih2cy0KntJKA==" /></outline><outline text="Implement some() and every() as reduce"><outline text="var data = [&#xA;    {userID: 1, name: &quot;Ryan&quot;, groups: [&quot;dev&quot;, &quot;ops&quot;, &quot;qa&quot;, &quot;employee&quot;]},&#xA;    {userID: 2, name: &quot;Bob&quot;, groups: [&quot;ops&quot;, &quot;employee&quot;]},&#xA;    {userID: 3, name: &quot;John&quot;, groups: [&quot;qa&quot;, &quot;employee&quot;]},&#xA;    {userID: 4, name: &quot;Paul&quot;, groups: [&quot;dev&quot;, &quot;qa&quot;, &quot;employee&quot;]}&#xA;];&#xA;&#xA;var isDev = function (user) {&#xA;    return user.groups.includes(&quot;dev&quot;);&#xA;};&#xA;&#xA;var isEmployee = function(user) {&#xA;    return user.groups.includes(&quot;employee&quot;);   &#xA;};&#xA;&#xA;var isManager = function(user) {&#xA;    return user.groups.includes(&quot;manager&quot;);   &#xA;};&#xA;&#xA;// every isDev&#xA;data.reduce(function(result, user) {&#xA;   return result &amp;&amp; isDev(user);&#xA;}, true);  &#xA;// false, not everyone is a dev&#xA;&#xA;// every isEmployee &#xA;data.reduce(function(result, user) {&#xA;   return result &amp;&amp; isEmployee(user);&#xA;}, true);&#xA;// true, everyone is an employee&#xA;&#xA;// some isDev  &#xA;data.reduce(function(result, user) {&#xA;   return result || isDev(user);&#xA;}, false);  &#xA;// true, at least one user is a dev&#xA;&#xA;// some isManager&#xA;data.reduce(function(result, user) {&#xA;   return result || isManager(user);&#xA;}, false);  &#xA;// false, no user is a manager"><sx:sync version="1" id="b7YudBzEnUWQR+Ll/4n/zQ==" /></outline><sx:sync version="1" id="M3eRq/GjfU+E2hLIbY1B0Q==" /></outline><outline text="Cowboy trick - First map() array values to appropriate format before reducing to a single value."><sx:sync version="1" id="MmyWXHH10kuxTorXWnz0WA==" /></outline><outline text="Returns value that results from reduction"><sx:sync version="1" id="LAkxAPWj30WhjZWEx+aUoA==" /></outline><sx:sync version="1" id="kwfFLZru7UmLTmQ47HS+sg==" /></outline><outline text="find()"><outline text="returns the value of first element in the array that satisfies the test function"><sx:sync version="1" id="r8tMFfcJhU+N45yOUFcEwg==" /></outline><outline text="If no values satisfy the test, reutrns undefined"><sx:sync version="1" id="iSz0o81RoUWKjprxVXD8xw==" /></outline><outline text="const array1 = [5, 12, 8, 130, 44];&#xA;&#xA;const found = array1.find(element =&gt; element &gt; 10);&#xA;&#xA;console.log(found);  //  12"><sx:sync version="1" id="SqtAohafy0CyU69/whlcxw==" /></outline><sx:sync version="1" id="TE6L6Oi8qEaUwAqwMbTcPw==" /></outline><outline text="findIndex()"><outline text="returns index of first element in the array that satisfies the test function"><sx:sync version="1" id="VNxiLwPxCk2+uc02p8m8LQ==" /></outline><outline text="If no element passes the test, returns -1"><sx:sync version="1" id="ZtOGkNxKV0623GksK33a4w==" /></outline><sx:sync version="1" id="9hqSPTCA902ww122wPW+PQ==" /></outline><outline text="Chaining w/ arrow functions MPJ"><outline text="Arrow functions - MPJ"><outline text="let dragonEvents = [&#xA;{ type: 'attack', value: 12, target: 'dorkman' },&#xA;{ type: 'yawn', value: 40 },&#xA;{ type: 'attack', value: 40, target: 'fluffy' },&#xA;{ type: 'eat', value: 3, target: 'horse'},&#xA;{ type: 'attack', value: 40, target: 'fluffy' },&#xA;{ type: 'attack', value: 12, target: 'dorkman' }&#xA;];"><sx:sync version="1" id="l37S5TrI00avbomIfUgfHQ==" /></outline><outline text="Conventional function syntax -"><sx:sync version="1" id="lHH8nEWt0EqTzbH75Z9rQw==" /></outline><outline text="const totalDorkDamage = dragonEvents&#xA;  .filter(function(event) {&#xA;    return event.type === 'attack'&#xA;  })&#xA;  .filter(function(event) {&#xA;    return event.target === 'dorkman'&#xA;  })&#xA;  .map(function(event) {&#xA;    return event.value;&#xA;  })&#xA;  .reduce(function(prev, value) {&#xA;    return (prev || 0) + value&#xA;  })&#xA;console.log(totalDorkDamage);"><sx:sync version="1" id="gtTY4bNtxUKZyh0I6w30ng==" /></outline><outline text="Eliminate function keyword -"><sx:sync version="1" id="yjo8PKXpUkKtffR3HhcheQ==" /></outline><outline text="What it means - &#xA;“This input (the parameters) produces this result (the body)”."><sx:sync version="1" id="LVcS41edFUmyYBUtxAcnmQ==" /></outline><outline text="const totalFluffyDamage = dragonEvents&#xA;  .filter((event) =&gt; {&#xA;    return event.type === 'attack'&#xA;  })&#xA;  .filter((event) =&gt; {&#xA;    return event.target === 'fluffy'&#xA;  })&#xA;  .map((event) =&gt; {&#xA;    return event.value&#xA;  })&#xA;  .reduce((prev, value) =&gt; {&#xA;    return (prev || 0) + value&#xA;  })&#xA;console.log(totalFluffyDamage);"><sx:sync version="1" id="NRPTyL5mikiqmWWOXj4iAg==" /></outline><outline text="Also eliminate return keyword and curly braces -"><sx:sync version="1" id="wCN2ye/3hkuLPHm+be/tbA==" /></outline><outline text="const totalVal40 = dragonEvents&#xA;&#xA;    .filter((event) =&gt; event.type !== 'attack')&#xA;    .filter(event =&gt; event.target === 'horse')&#xA;    .map((event) =&gt; event.value)&#xA;    .reduce((prev, value) =&gt; (prev || 0) + value);&#xA;&#xA;console.log(totalVal40);"><sx:sync version="1" id="01jeWzc8mU+E1mgOPoVezw==" /></outline><outline text="Sometimes you can omit parentheses around a single parameter"><outline text="const square2 = x =&gt; x * x;"><sx:sync version="1" id="3BId3sPnZEaDvf+JTC+UhQ==" /></outline><outline text="But then you can't chain functions together"><sx:sync version="1" id="+LOtNMrOLEGW/WvowOP26w==" /></outline><sx:sync version="1" id="KLSPVKSQhEm+4bYrK8Fjuw==" /></outline><sx:sync version="1" id="L2PQmay6REi73FhGtlr8wg==" /></outline><outline text="Implicit return values"><outline text="Implicit return, but only if there is no block."><outline text="Warning - Errors occur when a one-liner expands to multiple lines and dev forgets to add a return."><sx:sync version="1" id="DLcg4M1MRUOdwi0MlvMnJA==" /></outline><outline text="Implicit return is syntactically ambiguous&#xA; (name) =&gt; {id: name} returns object {id: name}... right? &#xA;Wrong - Returns undefined. Braces are an explicit block. id: is a label."><sx:sync version="1" id="oianVTkvhECh3jsmHK+YSA==" /></outline><sx:sync version="1" id="3aS2h/5lF0OrMLr6o87zxw==" /></outline><outline text="Examples"><outline text="// returns: undefined&#xA;// explanation: an empty block with an implicit return&#xA;((name) =&gt; {})() &#xA;&#xA;// returns: 'Hi Jess'&#xA;// explanation: no block means implicit return&#xA;((name) =&gt; 'Hi ' + name)('Jess')&#xA;&#xA;// returns: undefined&#xA;// explanation: explicit return required inside block, but is missing.&#xA;((name) =&gt; {'Hi ' + name})('Jess')&#xA;&#xA;// returns: 'Hi Jess'&#xA;// explanation: explicit return in block exists&#xA;((name) =&gt; {return 'Hi ' + name})('Jess') &#xA;&#xA;// returns: undefined&#xA;// explanation: a block containing a single label. No explicit return.&#xA;((name) =&gt; {id: name})('Jess') &#xA;&#xA;// returns: {id: 'Jess'}&#xA;// explanation: implicit return of expression ( ) which evaluates to an object&#xA;((name) =&gt; ({id: name}))('Jess') &#xA;&#xA;// returns: {id: 'Jess'}&#xA;// explanation: explicit return inside block returns object&#xA;((name) =&gt; {return {id: name}})('Jess') "><sx:sync version="1" id="VKzVEIdsPky+SicDRs4cPA==" /></outline><sx:sync version="1" id="1eHY/SbDHEeucnSV9Et19A==" /></outline><outline text=""><sx:sync version="1" id="zY4/y7+7XUW39Wt5Xiooww==" /></outline><sx:sync version="1" id="y99quhUfwEO5iOe0HypXfw==" /></outline><outline text="Chaining it all together -"><outline text="var monday = [&#xA;        {&#xA;            'name'     : 'Write a tutorial',&#xA;            'duration' : 180&#xA;        },&#xA;        {&#xA;            'name'     : 'Some web development',&#xA;            'duration' : 120&#xA;        }&#xA;    ];&#xA; &#xA;var tuesday = [&#xA;        {&#xA;            'name'     : 'Keep writing tutorial',&#xA;            'duration' : 240&#xA;        },&#xA;        {&#xA;            'name'     : 'More web development',&#xA;            'duration' : 180&#xA;        },&#xA;        {&#xA;            'name'     : 'Do a selfless action',&#xA;            'duration'  : 240&#xA;        }&#xA;    ];&#xA;     &#xA;var tasks = [monday, tuesday];"><sx:sync version="1" id="bCB4+Cn4dk+IfsNVdKefQg==" /></outline><outline text="var result = tasks.reduce(function (accumulator, current) {&#xA;                    return accumulator.concat(current);&#xA;                }).map(function (task) {&#xA;                    return (task.duration / 60);&#xA;                }).filter(function (duration) {&#xA;                    return duration &gt;= 2;&#xA;                }).map(function (duration) {&#xA;                    return duration * 25;&#xA;                }).reduce(function (accumulator, current) {&#xA;                   /* plus signs in front of accumulator and &#xA;                      current coerce their values to numbers */&#xA;                    return [(+accumulator) + (+current)];&#xA;                }).map(function (dollar_amount) {&#xA;                    return '$' + dollar_amount.toFixed(2);&#xA;                }).reduce(function (formatted_dollar_amount) {&#xA;                    return formatted_dollar_amount;&#xA;                });"><sx:sync version="1" id="QPxeZcBDD02N1QT2E2C2KQ==" /></outline><outline text="More concisely -"><sx:sync version="1" id="lqDekUk6t06sIylhGhY2Jg==" /></outline><outline text="                  // Concatenate 2D array into a single list&#xA;var result = tasks.reduce((acc, current) =&gt; acc.concat(current))&#xA;                  // Extract task duration, convert minutes to hours&#xA;                  .map((task) =&gt; task.duration / 60)&#xA;                  // Filter out tasks that took less than two hours&#xA;                  .filter((duration) =&gt; duration &gt;= 2)&#xA;                  // Multiply task duration by hourly rate&#xA;                  .map((duration) =&gt; duration * 25)&#xA;                  // Combine sums into total amount&#xA;                  .reduce((acc, current) =&gt; [(+acc) + (+current)])&#xA;                  // Convert to nice format&#xA;                  .map((amount) =&gt; '$' + amount.toFixed(2))&#xA;                  // Pull out the only element of array we got from map&#xA;                  .reduce((formatted_amount) =&gt;formatted_amount);"><sx:sync version="1" id="6Gvguvu/V0aU190qcKcfcA==" /></outline><sx:sync version="1" id="5PcBDwBgxEiudyUQ/oyNgw==" /></outline><outline text="reduce"><sx:sync version="1" id="iuMmp7bQYEW5r4Cqgu2grw==" /></outline><outline text="map reduce filter "><sx:sync version="1" id="6bzzQVr10EuuIpuEu1aHSQ==" /></outline><outline text="Link 6"><sx:sync version="1" id="2hd+RRv9a0yNHIRdZ+aRQQ==" /></outline><sx:sync version="1" id="jg/rMfBAIkeqo4K7c0czrQ==" /></outline><outline text="forEach()"><outline text="Preferred way to iterate an array"><sx:sync version="1" id="vIbQnDU2zUekTO1EwhfNVw==" /></outline><outline text="- invokes a function for each element"><sx:sync version="1" id="SnwOysbWCUSMwYLSvEFCJw==" /></outline><outline text="var array = [1, 2, 3];&#xA;array.forEach(item =&gt; {&#xA; console.log(item);&#xA;});"><sx:sync version="1" id="2uk1fxka00iWldtd3tH+eg==" /></outline><outline text="Is it destructive?"><outline text="does not mutate original array"><sx:sync version="1" id="nOgDKRZRA0Ojd+GK9uUwDQ==" /></outline><outline text="However, callback may do so"><sx:sync version="1" id="rnwYUvxfD0qaDLJBGTyElA==" /></outline><sx:sync version="1" id="SfRMduTfdE+0HwkLOv04KA==" /></outline><outline text="Example"><outline text="(function() {&#xA;  var movies = [&#xA;      {&#xA;        &quot;id&quot;: 70111470,&#xA;        &quot;title&quot;: &quot;Die Hard&quot;,&#xA;      },&#xA;      {&#xA;        &quot;id&quot;: 675465,&#xA;        &quot;title&quot;: &quot;Fracture&quot;&#xA;      }&#xA;    ],&#xA;    moviesSimple = [];&#xA;&#xA;  movies.forEach(vid =&gt; {&#xA;    moviesSimple.push({ id: vid.id, name: vid.title });&#xA;  });&#xA;  console.log(moviesSimple);&#xA;  return moviesSimple;&#xA;}) ();"><sx:sync version="1" id="TqGCeVFh/0uPjbh8KMmS+Q==" /></outline><sx:sync version="1" id="O7WDR+jVmkS74fdfxN5WBQ==" /></outline><outline text="Old function syntax"><outline text="Shows syntax, doesn't execute -"><sx:sync version="1" id="Y9gk3LEin0CZ2va0KccVIg==" /></outline><outline text="arr.forEach(function callback(currentValue[, index[, array]]) {&#xA;    //your iterator&#xA;}[, thisArg]);"><sx:sync version="1" id="ADmROwxXGUiXLBo21mq0Zw==" /></outline><outline text="var arr = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;];&#xA;arr.forEach(function callback(item [, index[, array]]) {&#xA;    // your iterator&#xA;    console.log(item);&#xA;});"><sx:sync version="1" id="L6z56uVqzkOJl6K1w6mlCg==" /></outline><sx:sync version="1" id="iN08+hKxzUCh86ud/bx5Yw==" /></outline><outline text="Parameters to forEach"><outline text="callback function"><sx:sync version="1" id="YUWSFEcxnU6FTn3P+nXn7Q==" /></outline><outline text="thisArg"><outline text="Value to use as this (i.e the reference Object) when executing callback"><sx:sync version="1" id="b+Dm09cCzkGr64b0Fcr1AQ==" /></outline><sx:sync version="1" id="WUyb0Y0rt0OG3RslE2eshw==" /></outline><sx:sync version="1" id="Xa2QmTl3gUGfmQ1mqYGZUw==" /></outline><outline text="Parameters to callback function"><outline text="currentValue - value of current element being processed in the array"><sx:sync version="1" id="ZEqtAHbsoEih5P78/ZdHDA==" /></outline><outline text="index - index of current element being processed in the array"><sx:sync version="1" id="B0yUWLPV70mgFotchorYAQ==" /></outline><outline text="array - array that forEach() is being applied to "><sx:sync version="1" id="G8npAO1ry0e8rgt9aBCiHA==" /></outline><sx:sync version="1" id="YNDKitePlk+VLLj2doUaEg==" /></outline><outline text="Return value - undefined"><sx:sync version="1" id="gi4JpOjFl06gsO9A4HY/Ww==" /></outline><outline text="forEach vs map/filter/reduce"><outline text="- forEach is usually not the tool to use with pure functions"><sx:sync version="1" id="/f8lrb1kFUSYNtzn4tvDpA==" /></outline><outline text="(A pure function has no side effects)"><sx:sync version="1" id="2RTLDLeXa0WDGFJ9yoIcTA==" /></outline><outline text="- map, filter, and reduce are better tools for pure functions"><outline text="Why?"><sx:sync version="1" id="BVI1wE4GwUmXbwOLNNYFEA==" /></outline><outline text="Because forEach has side effects"><sx:sync version="1" id="NFB9AEAIKU6RYvmM6ogCEQ==" /></outline><sx:sync version="1" id="AyQJVTTfJkym5/z6ebCf6A==" /></outline><outline text="- use forEach when side effects are necessary - "><outline text="- referencing outside variables (such as through closure)"><sx:sync version="1" id="6ecNR+FyRkGfjFYpzAuEQg==" /></outline><outline text="- writing output to screen"><sx:sync version="1" id="5cSAXwivEkGFHe6xAQHdaw==" /></outline><outline text="- talking to DB"><sx:sync version="1" id="72j1D/fZqEq5trauQvPraA==" /></outline><sx:sync version="1" id="y49b2v/b50meblOKYO4DWA==" /></outline><outline text="Start out using map, filter, reduce"><outline text="then send output to forEach where side effects are produced in centralized area."><sx:sync version="1" id="QzxJ1zm3NEqIAHqiGoPlPA==" /></outline><outline text="Easier to test and maintain"><sx:sync version="1" id="JYh9wbMiVEmqc556/Ji5Xw==" /></outline><sx:sync version="1" id="MezzSh3En0itZUH+MlIUgg==" /></outline><sx:sync version="1" id="i+Y66KDpb0GOTKz7xjCnvg==" /></outline><outline text="w/ arrow function"><outline text="arr.forEach(element =&gt; {&#xA;    console.log(element);&#xA;});"><sx:sync version="1" id="8tQlldOzgkufkTA5KV+yOA==" /></outline><outline text="this.markers.forEach((markerInfo, idx) =&gt; {&#xA;    console.log('current index is ' + idx);&#xA;}"><sx:sync version="1" id="P101Pu2rmEyC8qJn1xas6g==" /></outline><sx:sync version="1" id="v3k9cv9q+UCJOPKDz+yPTw==" /></outline><outline text="Callback can be named"><outline text="arr.forEach(function myCallback(currentValue[, index[, array]]) {&#xA;    //your iterator&#xA;    console.log(element);&#xA;}[, thisArg]);"><sx:sync version="1" id="NDdiuif3HkCr2MvLsHg9ZQ==" /></outline><sx:sync version="1" id="pS/QjkWbvEigboLXTT0gaA==" /></outline><outline text="Compare forEach / for / for...of / reduce"><outline text="Sum an array -"><sx:sync version="1" id="yE5rVpROMUmOK7S8HbrleQ==" /></outline><outline text="let add_w_for = (arr) =&gt; {&#xA;  let sum = 0;&#xA;  for (let i = 0; i &lt; arr.length; i++) {&#xA;    sum += arr[i]&#xA;  }&#xA;  return sum&#xA;}"><sx:sync version="1" id="uB1xP14pJUe+QFMLm3wJWA==" /></outline><outline text="let add_w_for_of = (arr) =&gt; {&#xA;  let sum = 0&#xA;  for(let elem of arr) {&#xA;    sum += elem&#xA;  }&#xA;  return sum&#xA;}"><sx:sync version="1" id="MO7Tx68vuEe4Sb1qrE2yzA==" /></outline><outline text="let add_w_foreach = (arr) =&gt; {&#xA;  let sum = 0&#xA;  arr.forEach(elem =&gt; {&#xA;    sum += elem&#xA;  })&#xA;  return sum&#xA;}"><sx:sync version="1" id="S3r86BM8nEuEOsoJn3vxwQ==" /></outline><outline text="let add_w_reduce = (arr) =&gt; {&#xA;  return arr.reduce((acc, elem) =&gt; {&#xA;    return acc + elem&#xA;  }, 0)&#xA;}"><sx:sync version="1" id="Y+pfh9dJ6ESeDycHqC89NQ==" /></outline><sx:sync version="1" id="yx+0AIfCK0mXonGWofe/LQ==" /></outline><sx:sync version="1" id="WEgbQ24PhkOUZ6VwX0OuLw==" /></outline><outline text="for... of"><outline text="About"><outline text="- iterates Array, Map, Set, String, TypedArray, arguments object"><sx:sync version="1" id="EKZpeLFOA06ztLlt/jD44A==" /></outline><outline text="- NOT for other objects"><sx:sync version="1" id="vi8DJtjfcE2UrXJ1io8lQA==" /></outline><outline text="- invokes a custom iteration hook with statements to be executed for the value of each property."><sx:sync version="1" id="vb6GE2cZLU+cjCeTCzI5bw==" /></outline><outline text="- iterates innumerable properties only"><sx:sync version="1" id="1NMPUFTE0USazEJQSNEmoQ==" /></outline><sx:sync version="1" id="qPaK1Wi/EUe0me2Z1Shz1w==" /></outline><outline text="Basic syntax"><outline text="for (variable of iterable) {&#xA;  // statement&#xA;}"><sx:sync version="1" id="zhIi3UFCF0CjWajoiSRdKA==" /></outline><outline text="variable"><outline text="On each iteration, value of next index (or property) is assigned to variable."><sx:sync version="1" id="/dHjA4fw/0iUvZsGyNa/Cw==" /></outline><sx:sync version="1" id="KyzAhfY5YEasJ5ytbwJ62w==" /></outline><outline text="iterable"><outline text="Object whose properties are iterated."><sx:sync version="1" id="MWLIC/QfxEK7D3RUIgIwCQ==" /></outline><sx:sync version="1" id="JbrRXZ7yQ0GcLDb6+RRlwA==" /></outline><sx:sync version="1" id="McrISqwliES+lR8kzYcBaQ==" /></outline><outline text="How to iterate array - 2019"><outline text="for (const [i, val] of arr.entries())"><sx:sync version="1" id="K5fxcoAd50yKw5Qh3gxb3g==" /></outline><outline text="let thisArr = ['a', 'b', 'c', 'd'];&#xA;&#xA;for (const [index, val] of thisArr.entries()) {&#xA;  console.log('index :', index);&#xA;  // old syntax works&#xA;  console.log('thisArr[index] :', thisArr[index]);&#xA;  // new syntax is the beast!&#xA;  console.log('val :', val);&#xA;  if (val === 'c') {&#xA;    break;&#xA;  }&#xA;}"><sx:sync version="1" id="jJg75WgVb0SU5upTgPxyqw==" /></outline><outline text="const squareVals = (arr) =&gt; {&#xA;  for (let item of arr) {&#xA;    item = item * item;&#xA;    console.log('item :', item);&#xA;  }&#xA;  return arr;&#xA;}&#xA;&#xA;console.log(squareVals([1,2,3,4]));"><sx:sync version="1" id="TLkQG0Sd4E6kUDiLT/6+GA==" /></outline><outline text="Mutating version -"><sx:sync version="1" id="3Wdz39BmY0SeRkq8O+cmfQ==" /></outline><outline text="  for (let [idx, item] of arr.entries()) {&#xA;    item = item * item;&#xA;    arr[idx] = item;&#xA;  }"><sx:sync version="1" id="bBFki6/aB0SMICmyS7Wopw==" /></outline><sx:sync version="1" id="/3jN/qSjTEW9LusOvU7Wzw==" /></outline><outline text="Iterate Array"><outline text="let iterable = [10, 20, 30];&#xA;&#xA;for (let value of iterable) {&#xA;  value += 1;&#xA;  console.log(value);&#xA;}&#xA;// 11&#xA;// 21&#xA;// 31"><sx:sync version="1" id="n8eT6eRbgEaYwJ6FCVqv6A==" /></outline><outline text="var array = [1, 2, 3];&#xA;for(let element of array) {&#xA;  element += 1;&#xA;  console.log(element);&#xA;});&#xA;// 2&#xA;// 3&#xA;// 4"><sx:sync version="1" id="jfxyYveh7U2rBYQ4JQl/wA==" /></outline><sx:sync version="1" id="CJMcX8xpuEyTIhZeSojq1g==" /></outline><outline text="Iterate String"><outline text="let iterable = 'boo';&#xA;&#xA;for (let value of iterable) {&#xA;  console.log(value);&#xA;}&#xA;// &quot;b&quot;&#xA;// &quot;o&quot;&#xA;// &quot;o&quot;"><sx:sync version="1" id="+f5q/tIH2U6lQKscd9CSBw==" /></outline><sx:sync version="1" id="2q0m4gHnSkyPltzeVv693g==" /></outline><outline text="NO - Iterate Object"><outline text="Doesn't work"><sx:sync version="1" id="a+44O5tz1kKZTgegHT3YDA==" /></outline><outline text="let iterable = {10, 20, 30};&#xA;&#xA;for (let value of iterable) {&#xA;  value += 1;&#xA;  console.log(value);&#xA;}"><sx:sync version="1" id="KHr5g8wxt0qseWTyzDRDAg==" /></outline><outline text="Doesn't work"><sx:sync version="1" id="8YtVeyeRXEOSIcpolyY1wQ==" /></outline><outline text="let iterable = {a : 10, b : 20, k : 30};&#xA;for (let key, value in iterable) {&#xA;  console.log(value);&#xA;}"><sx:sync version="1" id="NKRLiiBeb0iwBU/Z/H5W1Q==" /></outline><sx:sync version="1" id="GqPM7a6xS0OPM3Dv8aj00w==" /></outline><outline text="Iterate Map"><outline text="let iterable = new Map([['a', 1], ['b', 2], ['c', 3]]);&#xA;&#xA;for (let entry of iterable) {&#xA;  console.log(entry);&#xA;}&#xA;// ['a', 1]&#xA;// ['b', 2]&#xA;// ['c', 3]&#xA;&#xA;for (let [key, value] of iterable) {&#xA;  console.log(value);&#xA;}&#xA;// 1&#xA;// 2&#xA;// 3"><sx:sync version="1" id="e41sJwDjA06EvCwrdKjAow==" /></outline><sx:sync version="1" id="scEDDSkDokyaCEl++/UXHg==" /></outline><outline text="Iterate Set"><outline text="let iterable = new Set([1, 1, 2, 2, 3, 3]);&#xA;&#xA;for (let value of iterable) {&#xA;  console.log(value);&#xA;}&#xA;// 1&#xA;// 2&#xA;// 3"><sx:sync version="1" id="8tfJ/t+A50+nG1p5WuqiRw==" /></outline><sx:sync version="1" id="GDvzoIYWzECKQgUWl3N2bw==" /></outline><outline text="Iterate arguments object"><outline text="(function() {&#xA;  for (let argument of arguments) {&#xA;    console.log(argument);&#xA;  }&#xA;})(1, 2, 3);&#xA;&#xA;// 1&#xA;// 2&#xA;// 3"><sx:sync version="1" id="4FCUboeKv0m8696Ov/N5yA==" /></outline><sx:sync version="1" id="SzrTKP98WU6HWnBUEytf8w==" /></outline><outline text="Iterate DOM collection"><outline text="- such as NodeList"><sx:sync version="1" id="9TK9B3gyLU6ohAIu0HVISA==" /></outline><outline text="Example - add small class to &lt;p&gt; that is direct descendants of &lt;article&gt;:"><sx:sync version="1" id="tZoL3d2I40qv6UyNnYR5Jw==" /></outline><outline text="// Only works in platforms that implement&#xA;// NodeList.prototype[Symbol.iterator]&#xA;&#xA;let articlePs = document.querySelectorAll('article &gt; p');&#xA;&#xA;for (let p of articlePs) {&#xA;  p.classList.add('small');&#xA;}"><sx:sync version="1" id="98wOKf3Ya0KXe+N9iBaPrA==" /></outline><sx:sync version="1" id="x7LtJcNqw0WK6aoj04Ey5w==" /></outline><sx:sync version="1" id="OoSPbGPxDkCJiUi6n7v8PQ==" /></outline><outline text="for"><outline text="for (var i = 0; i &lt; a.length; i++) {&#xA;   // Do something with a[i]&#xA;}"><sx:sync version="1" id="KVv73Iw74Ey1WBRGrurFBw==" /></outline><outline text="- Slightly inefficient because it looks up &quot;length&quot; again with each loop."><sx:sync version="1" id="4b/YdxmmA0uP65QrZGASuQ==" /></outline><outline text="Improved -"><outline text="for (var i = 0, len = a.length; i &lt; len; i++) {&#xA;   // Do something with a[i]&#xA;}"><sx:sync version="1" id="klt1vpU+H06JCBm1ijglUg==" /></outline><outline text="Advantage - Doesn't look up &quot;length&quot; with each loop"><sx:sync version="1" id="xqJE6x7QdUmwSyVjf8Rk0g==" /></outline><outline text="Preferred syntax for arrays that may contain &quot;falsy&quot; values, such as an empty string or a (numeric) zero. "><sx:sync version="1" id="94621PDB30mMVIT/AuZRMQ==" /></outline><sx:sync version="1" id="b0IWj37f5k212hd3FLptfg==" /></outline><outline text="Better sometimes -"><outline text="for (var i = 0, item; item = a[i++];) {&#xA;   // Do something with item&#xA;}"><sx:sync version="1" id="kTJTd4yp10ipiRWzfybPVQ==" /></outline><outline text="Use this syntax only for arrays which you know don't contain &quot;falsy&quot; values, such as arrays of objects or DOM nodes."><sx:sync version="1" id="HqrLoMz3LUmgJxk9WiBY7g==" /></outline><outline text="Middle part of loop -"><outline text="item = a[i++];"><sx:sync version="1" id="+E32KV97OkSR6QM6GFGAow==" /></outline><outline text="- Performs an assignment -"><sx:sync version="1" id="ufBLEnuFrUadp4cKSJidLw==" /></outline><outline text="- Tests for truthfulness.  "><sx:sync version="1" id="QcLLRHlzX0urk1tieqsFSw==" /></outline><outline text="(The second part of initializing a &quot;for&quot; loop is always a test that tells you when to stop looping.)"><sx:sync version="1" id="FqJgXwtZK0+r3Vmyzaxfmw==" /></outline><outline text="When a[i] comes up &quot;falsy&quot; such as &quot;undefined&quot;, that causes the loop to stop."><sx:sync version="1" id="s18WtWL3n0CaPx/I6HrRxw==" /></outline><outline text="When a[i] comes up &quot;truthy&quot;, the loop continues."><sx:sync version="1" id="jFVJGHqUCkiEDMrgx3N++w==" /></outline><outline text="With each increment of &quot;i&quot;, a value from the array is assigned to &quot;item&quot;, in sequential order."><sx:sync version="1" id="g0C/fwLU40qu9pN+ua2eKQ==" /></outline><outline text="(Note that 3rd component of loop initialization is blank.)"><sx:sync version="1" id="PmAdpczpFEipNF8XxKzLhw==" /></outline><sx:sync version="1" id="LEgz6WvmZkKgUg9rjZTXwg==" /></outline><sx:sync version="1" id="fQGkz/XZ0UOX3AHnzHwfKA==" /></outline><outline text="Example - iterate nested array"><outline text="function ticTacToe(console) {&#xA;  var ticTacToe = [&#xA;   ['x', 'o', 'o'],&#xA;   ['x', 'o', 'x'],&#xA;   ['o', 'o', 'x']&#xA;  ]&#xA;  for (var i = 0; i &lt; ticTacToe.length; i++) {&#xA;      for (var j = 0; j &lt; ticTacToe[i].length; j++) {&#xA;          console.log(ticTacToe[i][j]);&#xA;      }&#xA;  }&#xA;}"><sx:sync version="1" id="9hkZd5mUFUeORfWMzT+CfA==" /></outline><sx:sync version="1" id="oYlvi+3JGUSfDb5Phn2nCA==" /></outline><sx:sync version="1" id="yca8Skj9cEKB/lpDF1nExQ==" /></outline><outline text="for... in"><outline text="Warning - MDN says &quot;Don't use for arrays&quot;"><outline text="&quot;for...in should not be used to iterate over an Array where the index order is important.&quot;"><sx:sync version="1" id="n9NoLJJH0Uu5HWq7yxi0lw==" /></outline><sx:sync version="1" id="e/4xd2E/X06JjrHowKoHVw==" /></outline><outline text="for (var i in a) {&#xA;   // Do something with a[i]&#xA;}"><sx:sync version="1" id="c3LGG4VexEqf/AyVLrU/Ww==" /></outline><outline text="Advantage - Properties added to Array.prototype are also iterated"><sx:sync version="1" id="vq2ffrwReEWSP1j8l3X3YQ==" /></outline><outline text="var obj = {a: 1, b: 2, c: 3};&#xA;    &#xA;for (const prop in obj) {&#xA;  console.log(`obj.${prop} = ${obj[prop]}`);&#xA;}&#xA;&#xA;// Output:&#xA;// &quot;obj.a = 1&quot;&#xA;// &quot;obj.b = 2&quot;&#xA;// &quot;obj.c = 3&quot;Subtopic"><sx:sync version="1" id="TV1kiLDZ3UGgtSO/wIlqtQ==" /></outline><outline text="function studentCode(console) {&#xA;  var obj = {&#xA;    name: 'zoe',&#xA;    age: 40&#xA;  }&#xA;for (var x in obj) {&#xA;  // log the key&#xA;  console.log(&quot;key = &quot; + x);&#xA;  // then log the value&#xA;  console.log(&quot;value = &quot; + obj[x]);&#xA;    }&#xA;}&#xA;studentCode(console);"><sx:sync version="1" id="Uwi0P8cG6Eqkl4D7R1aZhA==" /></outline><sx:sync version="1" id="5KuTip33bUmPVSUII56QMQ==" /></outline><outline text="Clone an array"><outline text="const sheeps = ['🐑', '🐑', '🐑'];&#xA;&#xA;// Old way&#xA;const cloneSheeps = sheeps.slice();&#xA;&#xA;// ES6&#xA;const cloneSheepsES6 = [...sheeps];"><sx:sync version="1" id="1m4ewX/NWE2Bc4Uc9E58IA==" /></outline><sx:sync version="1" id="xAPkcyXs50mhtS1CG17BJA==" /></outline><outline text="rest"><outline text="- used to merge a list of function arguments into an array"><sx:sync version="1" id="CmPwgCOUIkGbptV7dIURjA==" /></outline><outline text="function joinThreeArrays(...items) {&#xA;  let result = [];&#xA;  for (let i = 0; i &lt; items.length; i++) {&#xA;    result = result.concat(items[i]);&#xA;  }&#xA;  return result;&#xA;}"><sx:sync version="1" id="5Gui55tcfEiJlxl6V4w/6A==" /></outline><outline text="// takes any number of parameters and converts them to an array"><sx:sync version="1" id="8aEOX8lptUCv7BpvxQRsfQ==" /></outline><outline text="Allows array methods to be applied to arguments"><outline text="sort, map, forEach, pop"><sx:sync version="1" id="84xFd0AAW0iFWM4YDzJtZA==" /></outline><sx:sync version="1" id="pY1grFcYkUSZh8ULJ17c0g==" /></outline><outline text="Only the last parameter can be a &quot;rest parameter&quot;."><sx:sync version="1" id="jrhsTyrJlkepUp9T7Mr3iA==" /></outline><outline text="A function's last parameter can be prefixed with ... which takes all remaining arguments and converts them to an array"><sx:sync version="1" id="8D487SHFyEmQ1aYuixFl+A==" /></outline><outline text="Note that the old school arguments object is not a real array"><sx:sync version="1" id="PGh5pLdLlEquxQc+Jfaymg==" /></outline><sx:sync version="1" id="mH4q8/4rsUywZlVIoYC+rA==" /></outline><outline text="entries"><outline text="let thisArr = ['a', 'b', 'c', 'd'];&#xA;&#xA;for (const [index, val] of thisArr.entries()) {&#xA;&#xA;  // bracket notation w/ index still works&#xA;  console.log('thisArr[index] :', thisArr[index]);&#xA;&#xA;  console.log('index :', index);&#xA;  console.log('val :', val);&#xA;  if (val === 'c') {&#xA;    break;&#xA;  }&#xA;}"><sx:sync version="1" id="H22x3z5cq0mObyroSireRg==" /></outline><sx:sync version="1" id="DdiTVS1SBEWvonEyQHZ8jQ==" /></outline><outline text="Sort array of objects"><outline text="const singers = [&#xA;  { name: 'Steven Tyler', band: 'Aerosmith', born: 1948 },&#xA;  { name: 'Karen Carpenter', band: 'The Carpenters', born: 1950 },&#xA;  { name: 'Kurt Cobain', band: 'Nirvana', born: 1967 },&#xA;  { name: 'Stevie Nicks', band: 'Fleetwood Mac', born: 1948 },&#xA;];&#xA;The following compare function compares the (uppercase) name of each band:&#xA;&#xA;function compare(a, b) {&#xA;  // Use toUpperCase() to ignore character casing&#xA;  const bandA = a.band.toUpperCase();&#xA;  const bandB = b.band.toUpperCase();&#xA;&#xA;  let comparison = 0;&#xA;  if (bandA &gt; bandB) {&#xA;    comparison = 1;&#xA;  } else if (bandA &lt; bandB) {&#xA;    comparison = -1;&#xA;  }&#xA;  return comparison;&#xA;}&#xA;&#xA;singers.sort(compare);"><sx:sync version="1" id="5o109WNKZ0i6zvPwqnpjxg==" /></outline><outline text="/* returns [&#xA;  { name: 'Steven Tyler', band: 'Aerosmith',  born: 1948 },&#xA;  { name: 'Stevie Nicks', band: 'Fleetwood Mac', born: 1948 },&#xA;  { name: 'Kurt Cobain', band: 'Nirvana', born: 1967 },&#xA;  { name: 'Karen Carpenter', band: 'The Carpenters', born: 1950 }&#xA;] */"><sx:sync version="1" id="18vgLoB54kODUXqR7jGEtA==" /></outline><outline text="const sortKeyPoints = (a, b) =&gt; {&#xA;  let comparison = 0;&#xA;  if (a.main_idx &gt; b.main_idx) {&#xA;    comparison = 1;&#xA;  } else if (a.main_idx &lt; b.main_idx) {&#xA;    comparison = -1;&#xA;  }&#xA;  return comparison;&#xA;}&#xA;&#xA;req.factory.key_pts.sort(sortKeyPoints);"><sx:sync version="1" id="4xTnZDqZIEW4wbapQ8Panw==" /></outline><sx:sync version="1" id="uciMPy3OKkW4cNZz/NEsfg==" /></outline><outline text="spread // array"><sx:sync version="1" id="YvMQwcZVMUeD9VJcYlHNkg==" /></outline></body></opml>
